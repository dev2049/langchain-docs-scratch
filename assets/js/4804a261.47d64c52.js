"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[43771],{3905:(e,t,n)=>{n.d(t,{Zo:()=>c,kt:()=>g});var a=n(67294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function d(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function i(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},o=Object.keys(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var s=a.createContext({}),l=function(e){var t=a.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):d(d({},t),e)),n},c=function(e){var t=l(e.components);return a.createElement(s.Provider,{value:t},e.children)},m="mdxType",p={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},u=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,o=e.originalType,s=e.parentName,c=i(e,["components","mdxType","originalType","parentName"]),m=l(n),u=r,g=m["".concat(s,".").concat(u)]||m[u]||p[u]||o;return n?a.createElement(g,d(d({ref:t},c),{},{components:n})):a.createElement(g,d({ref:t},c))}));function g(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var o=n.length,d=new Array(o);d[0]=u;var i={};for(var s in t)hasOwnProperty.call(t,s)&&(i[s]=t[s]);i.originalType=e,i[m]="string"==typeof e?e:r,d[1]=i;for(var l=2;l<o;l++)d[l]=n[l];return a.createElement.apply(null,d)}return a.createElement.apply(null,n)}u.displayName="MDXCreateElement"},75447:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>u,contentTitle:()=>m,default:()=>f,frontMatter:()=>c,metadata:()=>p,toc:()=>g});var a=n(87462),r=(n(67294),n(3905));const o=(d="CodeOutputBlock",function(e){return console.warn("Component "+d+" was not imported, exported, or provided by MDXProvider as global scope"),(0,r.kt)("div",e)});var d;const i={toc:[{value:"Setup",id:"setup",level:3},{value:"<code>embed_documents</code>",id:"embed_documents",level:3},{value:"Embed list of texts",id:"embed-list-of-texts",level:4},{value:"<code>embed_query</code>",id:"embed_query",level:3},{value:"Embed single query",id:"embed-single-query",level:4}]},s="wrapper";function l(e){let{components:t,...n}=e;return(0,r.kt)(s,(0,a.Z)({},i,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h3",{id:"setup"},"Setup"),(0,r.kt)("p",null,"To start we'll need to install the OpenAI Python package:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-bash"},"pip install openai\n")),(0,r.kt)("p",null,"Accessing the API requires an API key, which you can get by creating an account and heading ",(0,r.kt)("a",{parentName:"p",href:"https://platform.openai.com/account/api-keys"},"here"),". Once we have a key we'll want to set it as an environment variable by running:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-bash"},'export OPENAI_API_KEY="..."\n')),(0,r.kt)("p",null,"If you'd prefer not to set an environment variable you can pass the key in directly via the ",(0,r.kt)("inlineCode",{parentName:"p"},"openai_api_key")," named parameter when initiating the OpenAI LLM class:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},'from langchain.embeddings import OpenAIEmbeddings\n\nembeddings_model = OpenAIEmbeddings(openai_api_key="...")\n')),(0,r.kt)("p",null,"otherwise you can initialize without any params:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},"from langchain.embeddings import OpenAIEmbeddings\n\nembeddings_model = OpenAIEmbeddings()\n")),(0,r.kt)("h3",{id:"embed_documents"},(0,r.kt)("inlineCode",{parentName:"h3"},"embed_documents")),(0,r.kt)("h4",{id:"embed-list-of-texts"},"Embed list of texts"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},'embeddings = embedding_model.embed_documents(\n    [\n        "Hi there!",\n        "Oh, hello!",\n        "What\'s your name?",\n        "My friends call me World",\n        "Hello World!"\n    ]\n)\nlen(embeddings), len(embeddings[0])\n')),(0,r.kt)(o,{language:"python",mdxType:"CodeOutputBlock"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"(5, 1536)\n"))),(0,r.kt)("h3",{id:"embed_query"},(0,r.kt)("inlineCode",{parentName:"h3"},"embed_query")),(0,r.kt)("h4",{id:"embed-single-query"},"Embed single query"),(0,r.kt)("p",null,"Embed a single piece of text for the purpose of comparing to other embedded pieces of texts."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},'embedded_query = embedding_model.embed_query("What was the name mentioned in the conversation?")\nembedded_query[:5]\n')),(0,r.kt)(o,{language:"python",mdxType:"CodeOutputBlock"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"[0.0053587136790156364,\n -0.0004999046213924885,\n 0.038883671164512634,\n -0.003001077566295862,\n -0.00900818221271038]\n"))))}l.isMDXComponent=!0;const c={sidebar_position:2},m="Text embedding models",p={unversionedId:"modules/data_io/text_embedding/index",id:"modules/data_io/text_embedding/index",title:"Text embedding models",description:"The Embeddings class is a class designed for interfacing with text embedding models. There are lots of embedding model providers (OpenAI, Cohere, Hugging Face, etc) - this class is designed to provide a standard interface for all of them.",source:"@site/docs/modules/data_io/text_embedding/index.mdx",sourceDirName:"modules/data_io/text_embedding",slug:"/modules/data_io/text_embedding/",permalink:"/langchain-docs-scratch/docs/modules/data_io/text_embedding/",draft:!1,editUrl:"https://github.com/hwchase17/langchainjs/edit/main/docs/docs/modules/data_io/text_embedding/index.mdx",tags:[],version:"current",sidebarPosition:2,frontMatter:{sidebar_position:2},sidebar:"sidebar",previous:{title:"Split by tokens",permalink:"/langchain-docs-scratch/docs/modules/data_io/document_transformers/text_splitters/split_by_token"},next:{title:"Aleph Alpha",permalink:"/langchain-docs-scratch/docs/modules/data_io/text_embedding/integrations/aleph_alpha"}},u={},g=[{value:"Get started",id:"get-started",level:2}],h={toc:g},b="wrapper";function f(e){let{components:t,...n}=e;return(0,r.kt)(b,(0,a.Z)({},h,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"text-embedding-models"},"Text embedding models"),(0,r.kt)("p",null,"The Embeddings class is a class designed for interfacing with text embedding models. There are lots of embedding model providers (OpenAI, Cohere, Hugging Face, etc) - this class is designed to provide a standard interface for all of them."),(0,r.kt)("p",null,"Embeddings create a vector representation of a piece of text. This is useful because it means we can think about text in the vector space, and do things like semantic search where we look for pieces of text that are most similar in the vector space."),(0,r.kt)("p",null,"The base Embeddings class in LangChain exposes two methods: one for embedding documents and one for embedding a query. The former takes as input multiple texts, while the latter takes a single text. The reason for having these as two separate methods is that some embedding providers have different embedding methods for documents (to be searched over) vs queries (the search query itself)."),(0,r.kt)("h2",{id:"get-started"},"Get started"),(0,r.kt)(l,{mdxType:"GetStarted"}))}f.isMDXComponent=!0}}]);