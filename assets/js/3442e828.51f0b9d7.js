"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[34982],{3905:(e,t,n)=>{n.d(t,{Zo:()=>c,kt:()=>d});var r=n(67294);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,r,a=function(e,t){if(null==e)return{};var n,r,a={},o=Object.keys(e);for(r=0;r<o.length;r++)n=o[r],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(r=0;r<o.length;r++)n=o[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var p=r.createContext({}),l=function(e){var t=r.useContext(p),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},c=function(e){var t=l(e.components);return r.createElement(p.Provider,{value:t},e.children)},u="mdxType",m={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},h=r.forwardRef((function(e,t){var n=e.components,a=e.mdxType,o=e.originalType,p=e.parentName,c=s(e,["components","mdxType","originalType","parentName"]),u=l(n),h=a,d=u["".concat(p,".").concat(h)]||u[h]||m[h]||o;return n?r.createElement(d,i(i({ref:t},c),{},{components:n})):r.createElement(d,i({ref:t},c))}));function d(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var o=n.length,i=new Array(o);i[0]=h;var s={};for(var p in t)hasOwnProperty.call(t,p)&&(s[p]=t[p]);s.originalType=e,s[u]="string"==typeof e?e:a,i[1]=s;for(var l=2;l<o;l++)i[l]=n[l];return r.createElement.apply(null,i)}return r.createElement.apply(null,n)}h.displayName="MDXCreateElement"},8474:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>h,contentTitle:()=>u,default:()=>g,frontMatter:()=>c,metadata:()=>m,toc:()=>d});var r=n(87462),a=(n(67294),n(3905));const o=(i="CodeOutputBlock",function(e){return console.warn("Component "+i+" was not imported, exported, or provided by MDXProvider as global scope"),(0,a.kt)("div",e)});var i;const s={toc:[]},p="wrapper";function l(e){let{components:t,...n}=e;return(0,a.kt)(p,(0,r.Z)({},s,n,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-python"},"from langchain.chains.router import MultiPromptChain\nfrom langchain.llms import OpenAI\n")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-python"},'physics_template = """You are a very smart physics professor. \\\nYou are great at answering questions about physics in a concise and easy to understand manner. \\\nWhen you don\'t know the answer to a question you admit that you don\'t know.\n\nHere is a question:\n{input}"""\n\n\nmath_template = """You are a very good mathematician. You are great at answering math questions. \\\nYou are so good because you are able to break down hard problems into their component parts, \\\nanswer the component parts, and then put them together to answer the broader question.\n\nHere is a question:\n{input}"""\n')),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-python"},'prompt_infos = [\n    {\n        "name": "physics", \n        "description": "Good for answering questions about physics", \n        "prompt_template": physics_template\n    },\n    {\n        "name": "math", \n        "description": "Good for answering math questions", \n        "prompt_template": math_template\n    }\n]\n')),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-python"},"chain = MultiPromptChain.from_prompts(OpenAI(), prompt_infos, verbose=True)\n")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-python"},'print(chain.run("What is black body radiation?"))\n')),(0,a.kt)(o,{lang:"python",mdxType:"CodeOutputBlock"},(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},"    \n    \n    > Entering new MultiPromptChain chain...\n    physics: {'input': 'What is black body radiation?'}\n    > Finished chain.\n    \n    \n    Black body radiation is the emission of electromagnetic radiation from a body due to its temperature. It is a type of thermal radiation that is emitted from the surface of all objects that are at a temperature above absolute zero. It is a spectrum of radiation that is influenced by the temperature of the body and is independent of the composition of the emitting material.\n"))),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-python"},'print(chain.run("What is the first prime number greater than 40 such that one plus the prime number is divisible by 3"))\n')),(0,a.kt)(o,{lang:"python",mdxType:"CodeOutputBlock"},(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},"    \n    \n    > Entering new MultiPromptChain chain...\n    math: {'input': 'What is the first prime number greater than 40 such that one plus the prime number is divisible by 3'}\n    > Finished chain.\n    ?\n    \n    The first prime number greater than 40 such that one plus the prime number is divisible by 3 is 43. To solve this problem, we can break down the question into two parts: finding the first prime number greater than 40, and then finding a number that is divisible by 3. \n    \n    The first step is to find the first prime number greater than 40. A prime number is a number that is only divisible by 1 and itself. The next prime number after 40 is 41.\n    \n    The second step is to find a number that is divisible by 3. To do this, we can add 1 to 41, which gives us 42. Now, we can check if 42 is divisible by 3. 42 divided by 3 is 14, so 42 is divisible by 3.\n    \n    Therefore, the answer to the question is 43.\n"))),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-python"},'print(chain.run("What is the name of the type of cloud that rins"))\n')),(0,a.kt)(o,{lang:"python",mdxType:"CodeOutputBlock"},(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},"    \n    \n    > Entering new MultiPromptChain chain...\n    None: {'input': 'What is the name of the type of cloud that rains?'}\n    > Finished chain.\n    The type of cloud that typically produces rain is called a cumulonimbus cloud. This type of cloud is characterized by its large vertical extent and can produce thunderstorms and heavy precipitation. Is there anything else you'd like to know?\n"))))}l.isMDXComponent=!0;const c={},u="Dynamically selecting from multiple prompts",m={unversionedId:"modules/chains/integrations/multi_prompt_router",id:"modules/chains/integrations/multi_prompt_router",title:"Dynamically selecting from multiple prompts",description:"This notebook demonstrates how to use the RouterChain paradigm to create a chain that dynamically selects the prompt to use for a given input. Specifically we show how to use the MultiPromptChain to create a question-answering chain that selects the prompt which is most relevant for a given question, and then answers the question using that prompt.",source:"@site/docs/modules/chains/integrations/multi_prompt_router.mdx",sourceDirName:"modules/chains/integrations",slug:"/modules/chains/integrations/multi_prompt_router",permalink:"/langchain-docs-scratch/docs/modules/chains/integrations/multi_prompt_router",draft:!1,editUrl:"https://github.com/hwchase17/langchainjs/edit/main/docs/docs/modules/chains/integrations/multi_prompt_router.mdx",tags:[],version:"current",frontMatter:{},sidebar:"sidebar",previous:{title:"Moderation",permalink:"/langchain-docs-scratch/docs/modules/chains/integrations/moderation"},next:{title:"Dynamically selecting from multiple retrievers",permalink:"/langchain-docs-scratch/docs/modules/chains/integrations/multi_retrieval_qa_router"}},h={},d=[],y={toc:d},f="wrapper";function g(e){let{components:t,...n}=e;return(0,a.kt)(f,(0,r.Z)({},y,n,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("h1",{id:"dynamically-selecting-from-multiple-prompts"},"Dynamically selecting from multiple prompts"),(0,a.kt)("p",null,"This notebook demonstrates how to use the ",(0,a.kt)("inlineCode",{parentName:"p"},"RouterChain")," paradigm to create a chain that dynamically selects the prompt to use for a given input. Specifically we show how to use the ",(0,a.kt)("inlineCode",{parentName:"p"},"MultiPromptChain")," to create a question-answering chain that selects the prompt which is most relevant for a given question, and then answers the question using that prompt."),(0,a.kt)(l,{mdxType:"Example"}))}g.isMDXComponent=!0}}]);