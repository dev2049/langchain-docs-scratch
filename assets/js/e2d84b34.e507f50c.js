"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[23845],{3905:(e,n,t)=>{t.d(n,{Zo:()=>p,kt:()=>h});var a=t(67294);function o(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function l(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,a)}return t}function r(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?l(Object(t),!0).forEach((function(n){o(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):l(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function s(e,n){if(null==e)return{};var t,a,o=function(e,n){if(null==e)return{};var t,a,o={},l=Object.keys(e);for(a=0;a<l.length;a++)t=l[a],n.indexOf(t)>=0||(o[t]=e[t]);return o}(e,n);if(Object.getOwnPropertySymbols){var l=Object.getOwnPropertySymbols(e);for(a=0;a<l.length;a++)t=l[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(o[t]=e[t])}return o}var i=a.createContext({}),c=function(e){var n=a.useContext(i),t=n;return e&&(t="function"==typeof e?e(n):r(r({},n),e)),t},p=function(e){var n=c(e.components);return a.createElement(i.Provider,{value:n},e.children)},u="mdxType",m={inlineCode:"code",wrapper:function(e){var n=e.children;return a.createElement(a.Fragment,{},n)}},d=a.forwardRef((function(e,n){var t=e.components,o=e.mdxType,l=e.originalType,i=e.parentName,p=s(e,["components","mdxType","originalType","parentName"]),u=c(t),d=o,h=u["".concat(i,".").concat(d)]||u[d]||m[d]||l;return t?a.createElement(h,r(r({ref:n},p),{},{components:t})):a.createElement(h,r({ref:n},p))}));function h(e,n){var t=arguments,o=n&&n.mdxType;if("string"==typeof e||o){var l=t.length,r=new Array(l);r[0]=d;var s={};for(var i in n)hasOwnProperty.call(n,i)&&(s[i]=n[i]);s.originalType=e,s[u]="string"==typeof e?e:o,r[1]=s;for(var c=2;c<l;c++)r[c]=t[c];return a.createElement.apply(null,r)}return a.createElement.apply(null,t)}d.displayName="MDXCreateElement"},69909:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>i,contentTitle:()=>r,default:()=>g,frontMatter:()=>l,metadata:()=>s,toc:()=>c});var a=t(87462),o=(t(67294),t(3905));const l={},r="Logging to file",s={unversionedId:"modules/callbacks/how_to/filecallbackhandler",id:"modules/callbacks/how_to/filecallbackhandler",title:"Logging to file",description:"This example shows how to print logs to file. It shows how to use the FileCallbackHandler, which does the same thing as StdOutCallbackHandler, but instead writes the output to file. It also uses the loguru library to log other outputs that are not captured by the handler.",source:"@site/docs/modules/callbacks/how_to/filecallbackhandler.md",sourceDirName:"modules/callbacks/how_to",slug:"/modules/callbacks/how_to/filecallbackhandler",permalink:"/langchain-docs-scratch/docs/modules/callbacks/how_to/filecallbackhandler",draft:!1,editUrl:"https://github.com/hwchase17/langchainjs/edit/main/docs/docs/modules/callbacks/how_to/filecallbackhandler.md",tags:[],version:"current",frontMatter:{},sidebar:"sidebar",previous:{title:"Callbacks for custom chains",permalink:"/langchain-docs-scratch/docs/modules/callbacks/how_to/custom_chain"},next:{title:"Multiple callback handlers",permalink:"/langchain-docs-scratch/docs/modules/callbacks/how_to/multiple_callbacks"}},i={},c=[],p=e=>function(n){return console.warn("Component "+e+" was not imported, exported, or provided by MDXProvider as global scope"),(0,o.kt)("div",n)},u=p("CodeOutputBlock"),m=p("HTMLOutputBlock"),d={toc:c},h="wrapper";function g(e){let{components:n,...t}=e;return(0,o.kt)(h,(0,a.Z)({},d,t,{components:n,mdxType:"MDXLayout"}),(0,o.kt)("h1",{id:"logging-to-file"},"Logging to file"),(0,o.kt)("p",null,"This example shows how to print logs to file. It shows how to use the ",(0,o.kt)("inlineCode",{parentName:"p"},"FileCallbackHandler"),", which does the same thing as ",(0,o.kt)("a",{parentName:"p",href:"https://python.langchain.com/en/latest/modules/callbacks/getting_started.html#using-an-existing-handler"},(0,o.kt)("inlineCode",{parentName:"a"},"StdOutCallbackHandler")),", but instead writes the output to file. It also uses the ",(0,o.kt)("inlineCode",{parentName:"p"},"loguru")," library to log other outputs that are not captured by the handler."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-python"},"from loguru import logger\n\nfrom langchain.callbacks import FileCallbackHandler\nfrom langchain.chains import LLMChain\nfrom langchain.llms import OpenAI\nfrom langchain.prompts import PromptTemplate\n\nlogfile = 'output.log'\n\nlogger.add(logfile, colorize=True, enqueue=True)\nhandler = FileCallbackHandler(logfile)\n\nllm = OpenAI()\nprompt = PromptTemplate.from_template(\"1 + {number} = \")\n\n# this chain will both print to stdout (because verbose=True) and write to 'output.log'\n# if verbose=False, the FileCallbackHandler will still write to 'output.log'\nchain = LLMChain(llm=llm, prompt=prompt, callbacks=[handler], verbose=True)\nanswer = chain.run(number=2)\nlogger.info(answer)\n")),(0,o.kt)(u,{lang:"python",mdxType:"CodeOutputBlock"},(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"    \n    \n    > Entering new LLMChain chain...\n    Prompt after formatting:\n    1 + 2 = \n\n\n    \x1b[32m2023-06-01 18:36:38.929\x1b[0m | \x1b[1mINFO    \x1b[0m | \x1b[36m__main__\x1b[0m:\x1b[36m<module>\x1b[0m:\x1b[36m20\x1b[0m - \x1b[1m\n    \n    3\x1b[0m\n\n\n    \n    > Finished chain.\n"))),(0,o.kt)("p",null,"Now we can open the file ",(0,o.kt)("inlineCode",{parentName:"p"},"output.log")," to see that the output has been captured."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-bash"},"pip install ansi2html > /dev/null\n")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-python"},"from IPython.display import display, HTML\nfrom ansi2html import Ansi2HTMLConverter\n\nwith open('output.log', 'r') as f:\n    content = f.read()\n\nconv = Ansi2HTMLConverter()\nhtml = conv.convert(content, full=True)\n\ndisplay(HTML(html))\n")),(0,o.kt)(m,{center:!0,mdxType:"HTMLOutputBlock"},(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-html"},'<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">\n<html>\n<head>\n<meta http-equiv="Content-Type" content="text/html; charset=utf-8">\n<title></title>\n<style type="text/css">\n.ansi2html-content { display: inline; white-space: pre-wrap; word-wrap: break-word; }\n.body_foreground { color: #AAAAAA; }\n.body_background { background-color: #000000; }\n.inv_foreground { color: #000000; }\n.inv_background { background-color: #AAAAAA; }\n.ansi1 { font-weight: bold; }\n.ansi3 { font-style: italic; }\n.ansi32 { color: #00aa00; }\n.ansi36 { color: #00aaaa; }\n</style>\n</head>\n<body class="body_foreground body_background" style="font-size: normal;" >\n<pre class="ansi2html-content">\n\n\n<span class="ansi1">&gt; Entering new LLMChain chain...</span>\nPrompt after formatting:\n<span class="ansi1 ansi32"></span><span class="ansi1 ansi3 ansi32">1 + 2 = </span>\n\n<span class="ansi1">&gt; Finished chain.</span>\n<span class="ansi32">2023-06-01 18:36:38.929</span> | <span class="ansi1">INFO    </span> | <span class="ansi36">__main__</span>:<span class="ansi36">&lt;module&gt;</span>:<span class="ansi36">20</span> - <span class="ansi1">\n\n3</span>\n\n</pre>\n</body>\n\n</html>\n'))))}g.isMDXComponent=!0}}]);